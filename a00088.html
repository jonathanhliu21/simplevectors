<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simplevectors: svector::Vector&lt; D, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simplevectors
   &#160;<span id="projectnumber">0.3.9</span>
   </div>
   <div id="projectbrief">Simple vector implementations in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>svector</b></li><li class="navelem"><a class="el" href="a00088.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a00085.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">svector::Vector&lt; D, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A base vector representation.  
 <a href="a00088.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00026_source.html">vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for svector::Vector&lt; D, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a00087.png" border="0" usemap="#asvector_1_1Vector_3_01D_00_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="asvector_1_1Vector_3_01D_00_01T_01_4_inherit__map" id="asvector_1_1Vector_3_01D_00_01T_01_4_inherit__map">
<area shape="rect" title="A base vector representation." alt="" coords="104,5,279,32"/>
<area shape="rect" href="a00092.html" title="A simple 2D vector representation." alt="" coords="5,80,180,107"/>
<area shape="rect" href="a00096.html" title="A simple 3D vector representation." alt="" coords="204,80,379,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4c9b94cbfcc97c894149ff849fcea0e0"><td class="memItemLeft" align="right" valign="top"><a id="a4c9b94cbfcc97c894149ff849fcea0e0"></a>
typedef std::array&lt; T, D &gt;::<a class="el" href="a00088.html#a4c9b94cbfcc97c894149ff849fcea0e0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a4c9b94cbfcc97c894149ff849fcea0e0">iterator</a></td></tr>
<tr class="memdesc:a4c9b94cbfcc97c894149ff849fcea0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::array::iterator. <br /></td></tr>
<tr class="separator:a4c9b94cbfcc97c894149ff849fcea0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114147aca66dcebb6e2f718ff2fdf21a"><td class="memItemLeft" align="right" valign="top"><a id="a114147aca66dcebb6e2f718ff2fdf21a"></a>
typedef std::array&lt; T, D &gt;::<a class="el" href="a00088.html#a114147aca66dcebb6e2f718ff2fdf21a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a114147aca66dcebb6e2f718ff2fdf21a">const_iterator</a></td></tr>
<tr class="memdesc:a114147aca66dcebb6e2f718ff2fdf21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::array::const_iterator. <br /></td></tr>
<tr class="separator:a114147aca66dcebb6e2f718ff2fdf21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdec14f43e66c6b2204317f041d7185"><td class="memItemLeft" align="right" valign="top"><a id="adbdec14f43e66c6b2204317f041d7185"></a>
typedef std::array&lt; T, D &gt;::<a class="el" href="a00088.html#adbdec14f43e66c6b2204317f041d7185">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#adbdec14f43e66c6b2204317f041d7185">reverse_iterator</a></td></tr>
<tr class="memdesc:adbdec14f43e66c6b2204317f041d7185"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::array::reverse_iterator. <br /></td></tr>
<tr class="separator:adbdec14f43e66c6b2204317f041d7185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0346035577f39d20980aec3b2acc3839"><td class="memItemLeft" align="right" valign="top"><a id="a0346035577f39d20980aec3b2acc3839"></a>
typedef std::array&lt; T, D &gt;::<a class="el" href="a00088.html#a0346035577f39d20980aec3b2acc3839">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a0346035577f39d20980aec3b2acc3839">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a0346035577f39d20980aec3b2acc3839"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::array::const_reverse_iterator. <br /></td></tr>
<tr class="separator:a0346035577f39d20980aec3b2acc3839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e00d66b1b8a7f90a45a61f24b88834d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a0e00d66b1b8a7f90a45a61f24b88834d">Vector</a> ()</td></tr>
<tr class="memdesc:a0e00d66b1b8a7f90a45a61f24b88834d"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-argument constructor.  <a href="a00088.html#a0e00d66b1b8a7f90a45a61f24b88834d">More...</a><br /></td></tr>
<tr class="separator:a0e00d66b1b8a7f90a45a61f24b88834d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abfe9895c72adf1da5280f6db80db69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a7abfe9895c72adf1da5280f6db80db69">Vector</a> (const std::initializer_list&lt; T &gt; args)</td></tr>
<tr class="memdesc:a7abfe9895c72adf1da5280f6db80db69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a vector given initializer list.  <a href="a00088.html#a7abfe9895c72adf1da5280f6db80db69">More...</a><br /></td></tr>
<tr class="separator:a7abfe9895c72adf1da5280f6db80db69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e54dd0178d253b9a1945448836f2a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a90e54dd0178d253b9a1945448836f2a5">Vector</a> (const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;other)</td></tr>
<tr class="memdesc:a90e54dd0178d253b9a1945448836f2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="a00088.html#a90e54dd0178d253b9a1945448836f2a5">More...</a><br /></td></tr>
<tr class="separator:a90e54dd0178d253b9a1945448836f2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265d6629c6d07dc72e3050cb8c963423"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a265d6629c6d07dc72e3050cb8c963423">Vector</a> (<a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a265d6629c6d07dc72e3050cb8c963423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="a00088.html#a265d6629c6d07dc72e3050cb8c963423">More...</a><br /></td></tr>
<tr class="separator:a265d6629c6d07dc72e3050cb8c963423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa104c7240b64c743c6d8451504abe616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#aa104c7240b64c743c6d8451504abe616">operator=</a> (const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;other)</td></tr>
<tr class="memdesc:aa104c7240b64c743c6d8451504abe616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="a00088.html#aa104c7240b64c743c6d8451504abe616">More...</a><br /></td></tr>
<tr class="separator:aa104c7240b64c743c6d8451504abe616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc27e048d28bb5597c7b96cd1b89321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a8cc27e048d28bb5597c7b96cd1b89321">operator=</a> (<a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a8cc27e048d28bb5597c7b96cd1b89321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="a00088.html#a8cc27e048d28bb5597c7b96cd1b89321">More...</a><br /></td></tr>
<tr class="separator:a8cc27e048d28bb5597c7b96cd1b89321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe2ae62a95ea70f7065c0bd61a53553"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#affe2ae62a95ea70f7065c0bd61a53553">~Vector</a> ()=default</td></tr>
<tr class="memdesc:affe2ae62a95ea70f7065c0bd61a53553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="a00088.html#affe2ae62a95ea70f7065c0bd61a53553">More...</a><br /></td></tr>
<tr class="separator:affe2ae62a95ea70f7065c0bd61a53553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706197199863f1748ce354de928a13de"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a706197199863f1748ce354de928a13de">toString</a> () const</td></tr>
<tr class="memdesc:a706197199863f1748ce354de928a13de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string form of vector.  <a href="a00088.html#a706197199863f1748ce354de928a13de">More...</a><br /></td></tr>
<tr class="separator:a706197199863f1748ce354de928a13de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79529f4272bee3fb4a25a223e33c49d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a79529f4272bee3fb4a25a223e33c49d1">operator-</a> () const</td></tr>
<tr class="memdesc:a79529f4272bee3fb4a25a223e33c49d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative of a vector.  <a href="a00088.html#a79529f4272bee3fb4a25a223e33c49d1">More...</a><br /></td></tr>
<tr class="separator:a79529f4272bee3fb4a25a223e33c49d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13afee2758933db5cdb1acf28ad472d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a13afee2758933db5cdb1acf28ad472d6">operator+</a> () const</td></tr>
<tr class="memdesc:a13afee2758933db5cdb1acf28ad472d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive of a vector.  <a href="a00088.html#a13afee2758933db5cdb1acf28ad472d6">More...</a><br /></td></tr>
<tr class="separator:a13afee2758933db5cdb1acf28ad472d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aef72548b86be6fa4754922484941c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a3aef72548b86be6fa4754922484941c2">operator+=</a> (const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;other)</td></tr>
<tr class="memdesc:a3aef72548b86be6fa4754922484941c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition.  <a href="a00088.html#a3aef72548b86be6fa4754922484941c2">More...</a><br /></td></tr>
<tr class="separator:a3aef72548b86be6fa4754922484941c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e27aa7efedb7d0bdbace989238018d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a5e27aa7efedb7d0bdbace989238018d9">operator-=</a> (const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;other)</td></tr>
<tr class="memdesc:a5e27aa7efedb7d0bdbace989238018d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtraction.  <a href="a00088.html#a5e27aa7efedb7d0bdbace989238018d9">More...</a><br /></td></tr>
<tr class="separator:a5e27aa7efedb7d0bdbace989238018d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fcb661236fce31717f1e2d1282574e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ad6fcb661236fce31717f1e2d1282574e">operator*=</a> (const T other)</td></tr>
<tr class="memdesc:ad6fcb661236fce31717f1e2d1282574e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place scalar multiplication.  <a href="a00088.html#ad6fcb661236fce31717f1e2d1282574e">More...</a><br /></td></tr>
<tr class="separator:ad6fcb661236fce31717f1e2d1282574e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab312fad048da79f297c3b1d9103236b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ab312fad048da79f297c3b1d9103236b9">operator/=</a> (const T other)</td></tr>
<tr class="memdesc:ab312fad048da79f297c3b1d9103236b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place scalar division.  <a href="a00088.html#ab312fad048da79f297c3b1d9103236b9">More...</a><br /></td></tr>
<tr class="separator:ab312fad048da79f297c3b1d9103236b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c5febe15949c0b06bf9161ecc7cc98"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#aa8c5febe15949c0b06bf9161ecc7cc98">dot</a> (const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa8c5febe15949c0b06bf9161ecc7cc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product.  <a href="a00088.html#aa8c5febe15949c0b06bf9161ecc7cc98">More...</a><br /></td></tr>
<tr class="separator:aa8c5febe15949c0b06bf9161ecc7cc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee110a3ffb375d2a929b2ff949081ca"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a2ee110a3ffb375d2a929b2ff949081ca">magn</a> () const</td></tr>
<tr class="memdesc:a2ee110a3ffb375d2a929b2ff949081ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnitude.  <a href="a00088.html#a2ee110a3ffb375d2a929b2ff949081ca">More...</a><br /></td></tr>
<tr class="separator:a2ee110a3ffb375d2a929b2ff949081ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f87a5c8f27493f09d14108efaab47a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a4f87a5c8f27493f09d14108efaab47a4">normalize</a> () const</td></tr>
<tr class="memdesc:a4f87a5c8f27493f09d14108efaab47a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a vector.  <a href="a00088.html#a4f87a5c8f27493f09d14108efaab47a4">More...</a><br /></td></tr>
<tr class="separator:a4f87a5c8f27493f09d14108efaab47a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b51d8b845952b1c693e430c77ab220"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#af6b51d8b845952b1c693e430c77ab220">numDimensions</a> () const</td></tr>
<tr class="memdesc:af6b51d8b845952b1c693e430c77ab220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of dimensions.  <a href="a00088.html#af6b51d8b845952b1c693e430c77ab220">More...</a><br /></td></tr>
<tr class="separator:af6b51d8b845952b1c693e430c77ab220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a6f649b2cb3df258e180b4a31ba497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ae5a6f649b2cb3df258e180b4a31ba497">isZero</a> () const</td></tr>
<tr class="memdesc:ae5a6f649b2cb3df258e180b4a31ba497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the current vector is a zero vector.  <a href="a00088.html#ae5a6f649b2cb3df258e180b4a31ba497">More...</a><br /></td></tr>
<tr class="separator:ae5a6f649b2cb3df258e180b4a31ba497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5cb2cd0cab52f59df195d7809ba1ad"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#afb5cb2cd0cab52f59df195d7809ba1ad">operator[]</a> (const std::size_t index) const</td></tr>
<tr class="memdesc:afb5cb2cd0cab52f59df195d7809ba1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of a certain component of a vector.  <a href="a00088.html#afb5cb2cd0cab52f59df195d7809ba1ad">More...</a><br /></td></tr>
<tr class="separator:afb5cb2cd0cab52f59df195d7809ba1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf62ce931622e9acb55614b4170442e8"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#adf62ce931622e9acb55614b4170442e8">operator[]</a> (const std::size_t index)</td></tr>
<tr class="memdesc:adf62ce931622e9acb55614b4170442e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets value of a certain component.  <a href="a00088.html#adf62ce931622e9acb55614b4170442e8">More...</a><br /></td></tr>
<tr class="separator:adf62ce931622e9acb55614b4170442e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a600611b85c1d7e190634ed17f8b259"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a0a600611b85c1d7e190634ed17f8b259">at</a> (const std::size_t index) const</td></tr>
<tr class="memdesc:a0a600611b85c1d7e190634ed17f8b259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of a certain component of a vector.  <a href="a00088.html#a0a600611b85c1d7e190634ed17f8b259">More...</a><br /></td></tr>
<tr class="separator:a0a600611b85c1d7e190634ed17f8b259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef620526e8001af494bd793ea4a8f044"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#aef620526e8001af494bd793ea4a8f044">at</a> (const std::size_t index)</td></tr>
<tr class="memdesc:aef620526e8001af494bd793ea4a8f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets value of a certain component.  <a href="a00088.html#aef620526e8001af494bd793ea4a8f044">More...</a><br /></td></tr>
<tr class="separator:aef620526e8001af494bd793ea4a8f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448079b6fdc19f1bdb753f3b33c03934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#a4c9b94cbfcc97c894149ff849fcea0e0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a448079b6fdc19f1bdb753f3b33c03934">begin</a> () noexcept</td></tr>
<tr class="memdesc:a448079b6fdc19f1bdb753f3b33c03934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator of first element.  <a href="a00088.html#a448079b6fdc19f1bdb753f3b33c03934">More...</a><br /></td></tr>
<tr class="separator:a448079b6fdc19f1bdb753f3b33c03934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea758be24ad30640ebe49a801b775945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#a114147aca66dcebb6e2f718ff2fdf21a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#aea758be24ad30640ebe49a801b775945">begin</a> () const noexcept</td></tr>
<tr class="memdesc:aea758be24ad30640ebe49a801b775945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const interator of first element.  <a href="a00088.html#aea758be24ad30640ebe49a801b775945">More...</a><br /></td></tr>
<tr class="separator:aea758be24ad30640ebe49a801b775945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b984cf25cbc2043736a5673f03444a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#a4c9b94cbfcc97c894149ff849fcea0e0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a90b984cf25cbc2043736a5673f03444a">end</a> () noexcept</td></tr>
<tr class="memdesc:a90b984cf25cbc2043736a5673f03444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interator of last element + 1.  <a href="a00088.html#a90b984cf25cbc2043736a5673f03444a">More...</a><br /></td></tr>
<tr class="separator:a90b984cf25cbc2043736a5673f03444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efdfe65e424daca281d09d3341ab8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#a114147aca66dcebb6e2f718ff2fdf21a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a4efdfe65e424daca281d09d3341ab8d9">end</a> () const noexcept</td></tr>
<tr class="memdesc:a4efdfe65e424daca281d09d3341ab8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const interator of last element + 1.  <a href="a00088.html#a4efdfe65e424daca281d09d3341ab8d9">More...</a><br /></td></tr>
<tr class="separator:a4efdfe65e424daca281d09d3341ab8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2702f121eaef8d97f30b482fed56c509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#adbdec14f43e66c6b2204317f041d7185">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a2702f121eaef8d97f30b482fed56c509">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a2702f121eaef8d97f30b482fed56c509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator to last element.  <a href="a00088.html#a2702f121eaef8d97f30b482fed56c509">More...</a><br /></td></tr>
<tr class="separator:a2702f121eaef8d97f30b482fed56c509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d606c82599dda991cc95bdfce83daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#a0346035577f39d20980aec3b2acc3839">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a41d606c82599dda991cc95bdfce83daf">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a41d606c82599dda991cc95bdfce83daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reverse iterator to last element.  <a href="a00088.html#a41d606c82599dda991cc95bdfce83daf">More...</a><br /></td></tr>
<tr class="separator:a41d606c82599dda991cc95bdfce83daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142a7f6785eba59d5f3efb1f97cb22ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#adbdec14f43e66c6b2204317f041d7185">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a142a7f6785eba59d5f3efb1f97cb22ed">rend</a> () noexcept</td></tr>
<tr class="memdesc:a142a7f6785eba59d5f3efb1f97cb22ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator to first element - 1.  <a href="a00088.html#a142a7f6785eba59d5f3efb1f97cb22ed">More...</a><br /></td></tr>
<tr class="separator:a142a7f6785eba59d5f3efb1f97cb22ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604df9d4e4e6f410a82e156dd717a535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00088.html#a0346035577f39d20980aec3b2acc3839">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#a604df9d4e4e6f410a82e156dd717a535">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a604df9d4e4e6f410a82e156dd717a535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reverse iterator to first element - 1.  <a href="a00088.html#a604df9d4e4e6f410a82e156dd717a535">More...</a><br /></td></tr>
<tr class="separator:a604df9d4e4e6f410a82e156dd717a535"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa16867012cbc61db8d2296b49afec291"><td class="memItemLeft" align="right" valign="top"><a id="aa16867012cbc61db8d2296b49afec291"></a>
std::array&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#aa16867012cbc61db8d2296b49afec291">m_components</a></td></tr>
<tr class="memdesc:aa16867012cbc61db8d2296b49afec291"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of components for the vector. <br /></td></tr>
<tr class="separator:aa16867012cbc61db8d2296b49afec291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t D, typename T = double&gt;<br />
class svector::Vector&lt; D, T &gt;</h3>

<p>A base vector representation. </p>
<dl class="section note"><dt>Note</dt><dd>The binary +, -, *, /, ==, and != operators are by default implemented in <a class="el" href="a00041.html" title="Functions for the vector classes.">functions.hpp</a>. To use the class implementation rather than the one in <a class="el" href="a00041.html" title="Functions for the vector classes.">functions.hpp</a>, define the variable SVECTOR_USE_CLASS_OPERATORS.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>The number of dimensions. </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="a00088.html" title="A base vector representation.">Vector</a> type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0e00d66b1b8a7f90a45a61f24b88834d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e00d66b1b8a7f90a45a61f24b88834d">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::<a class="el" href="a00088.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No-argument constructor. </p>
<p>Initializes a zero vector (all components are 0). </p>

</div>
</div>
<a id="a7abfe9895c72adf1da5280f6db80db69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abfe9895c72adf1da5280f6db80db69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::<a class="el" href="a00088.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a vector given initializer list. </p>
<p>The initializer list should represent the components of the vector in each dimension. If the size of the initializer list is greater than the number of dimensions given, then the vector only initializes with the first D elements in the list, where D is the number of dimensions. If the size of the initializer list is less than the number of dimensions given, then the vector fills the rest of the dimensions with the value 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the initializer list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90e54dd0178d253b9a1945448836f2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e54dd0178d253b9a1945448836f2a5">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::<a class="el" href="a00088.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Copies from another vector to an uninitialized vector. </p>

</div>
</div>
<a id="a265d6629c6d07dc72e3050cb8c963423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265d6629c6d07dc72e3050cb8c963423">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::<a class="el" href="a00088.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Uses C++ default move constructor. </p>

</div>
</div>
<a id="affe2ae62a95ea70f7065c0bd61a53553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe2ae62a95ea70f7065c0bd61a53553">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::~<a class="el" href="a00088.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Uses C++ default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aef620526e8001af494bd793ea4a8f044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef620526e8001af494bd793ea4a8f044">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets value of a certain component. </p>
<p>Sets a certain component of the vector given the dimension number.</p>
<p>Throws an out_of_range exception if the given number is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The dimension number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a600611b85c1d7e190634ed17f8b259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a600611b85c1d7e190634ed17f8b259">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value of a certain component of a vector. </p>
<p>Gets a reference to a specific component of the vector given the dimension number.</p>
<p>Throws an out_of_range exception if the given number is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The dimension number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to that dimension's component of the vector. </dd></dl>

</div>
</div>
<a id="aea758be24ad30640ebe49a801b775945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea758be24ad30640ebe49a801b775945">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#a114147aca66dcebb6e2f718ff2fdf21a">const_iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const interator of first element. </p>
<p>Returns a constant iterator to the first dimension of the vector. This iterator will be equal to <a class="el" href="a00088.html#a90b984cf25cbc2043736a5673f03444a" title="Interator of last element + 1.">end()</a> for a zero-dimension vector.</p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the first dimension of the vector. </dd></dl>

</div>
</div>
<a id="a448079b6fdc19f1bdb753f3b33c03934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448079b6fdc19f1bdb753f3b33c03934">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#a4c9b94cbfcc97c894149ff849fcea0e0">iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator of first element. </p>
<p>Returns an iterator to the first dimension of the vector. This iterator will be equal to <a class="el" href="a00088.html#a90b984cf25cbc2043736a5673f03444a" title="Interator of last element + 1.">end()</a> for a zero-dimension vector.</p>
<p>This can be used for looping through the dimensions of a vector.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first dimension of the vector. </dd></dl>

</div>
</div>
<a id="aa8c5febe15949c0b06bf9161ecc7cc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c5febe15949c0b06bf9161ecc7cc98">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product. </p>
<p>Calculates the dot product of two vectors.</p>
<dl class="section note"><dt>Note</dt><dd>The dimensions of the other vector must be the same as the current one.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other vector to dot the current vector with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector representing the dot product of the two vectors. </dd></dl>

</div>
</div>
<a id="a4efdfe65e424daca281d09d3341ab8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efdfe65e424daca281d09d3341ab8d9">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#a114147aca66dcebb6e2f718ff2fdf21a">const_iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const interator of last element + 1. </p>
<p>Returns a constant iterator to the element following the last dimension of the vector.</p>
<p>This iterator is a placeholder and attempting to access it will result in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the element following the last dimension. </dd></dl>

</div>
</div>
<a id="a90b984cf25cbc2043736a5673f03444a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b984cf25cbc2043736a5673f03444a">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#a4c9b94cbfcc97c894149ff849fcea0e0">iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interator of last element + 1. </p>
<p>Returns an iterator to the element following the last dimension of the vector.</p>
<p>This iterator is a placeholder and attempting to access it will result in undefined behavior.</p>
<p>This can be used for looping through the dimensions of a vector.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last dimension. </dd></dl>

</div>
</div>
<a id="ae5a6f649b2cb3df258e180b4a31ba497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a6f649b2cb3df258e180b4a31ba497">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::isZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the current vector is a zero vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the current vector is a zero vector. </dd></dl>

</div>
</div>
<a id="a2ee110a3ffb375d2a929b2ff949081ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee110a3ffb375d2a929b2ff949081ca">&#9670;&nbsp;</a></span>magn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::magn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Magnitude. </p>
<p>Gets the magnitude of the vector.</p>
<dl class="section return"><dt>Returns</dt><dd>The magnitude of the vector. </dd></dl>

</div>
</div>
<a id="a4f87a5c8f27493f09d14108efaab47a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f87a5c8f27493f09d14108efaab47a4">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes a vector. </p>
<p>Finds the unit vector with the same direction angle as the current vector.</p>
<dl class="section note"><dt>Note</dt><dd>This method will result in undefined behavior if the vector is a zero vector (if the magnitude equals zero).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector representing the normalized vector. </dd></dl>

</div>
</div>
<a id="af6b51d8b845952b1c693e430c77ab220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b51d8b845952b1c693e430c77ab220">&#9670;&nbsp;</a></span>numDimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::numDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of dimensions. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of dimensions. </dd></dl>

</div>
</div>
<a id="ad6fcb661236fce31717f1e2d1282574e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fcb661236fce31717f1e2d1282574e">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt;&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place scalar multiplication. </p>
<p>Performs scalar multiplication on the current object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The number to multiply by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13afee2758933db5cdb1acf28ad472d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13afee2758933db5cdb1acf28ad472d6">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positive of a vector. </p>
<p>Creates new vector where the unary plus operator is applied to each component. In almost all cases, this returns the original vector.</p>
<dl class="section return"><dt>Returns</dt><dd>The current vector. </dd></dl>

</div>
</div>
<a id="a3aef72548b86be6fa4754922484941c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aef72548b86be6fa4754922484941c2">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt;&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place addition. </p>
<p>Adds another vector object to the current object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other vector to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79529f4272bee3fb4a25a223e33c49d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79529f4272bee3fb4a25a223e33c49d1">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negative of a vector. </p>
<p>Makes all components of the vector negative of what they currently are.</p>
<p>This can also be thought of flipping the direction of the vector.</p>
<dl class="section return"><dt>Returns</dt><dd>A new vector representing the negative of the current vector. </dd></dl>

</div>
</div>
<a id="a5e27aa7efedb7d0bdbace989238018d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e27aa7efedb7d0bdbace989238018d9">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt;&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place subtraction. </p>
<p>Subtracts another vector object from the current object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other vector to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab312fad048da79f297c3b1d9103236b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab312fad048da79f297c3b1d9103236b9">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt;&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place scalar division. </p>
<p>Performs scalar division on the current object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The number to divide by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa104c7240b64c743c6d8451504abe616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa104c7240b64c743c6d8451504abe616">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt;&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Copies from another vector to a vector whose values already exist. </p>

</div>
</div>
<a id="a8cc27e048d28bb5597c7b96cd1b89321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc27e048d28bb5597c7b96cd1b89321">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">Vector</a>&lt;D, T&gt;&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00088.html">Vector</a>&lt; D, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Uses C++ default move assignment operator. </p>

</div>
</div>
<a id="adf62ce931622e9acb55614b4170442e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf62ce931622e9acb55614b4170442e8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets value of a certain component. </p>
<p>Sets a certain component of the vector given the dimension number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The dimension number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb5cb2cd0cab52f59df195d7809ba1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5cb2cd0cab52f59df195d7809ba1ad">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value of a certain component of a vector. </p>
<p>Gets a reference to a specific component of the vector given the dimension number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The dimension number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to that dimension's component of the vector. </dd></dl>

</div>
</div>
<a id="a41d606c82599dda991cc95bdfce83daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d606c82599dda991cc95bdfce83daf">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#a0346035577f39d20980aec3b2acc3839">const_reverse_iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const reverse iterator to last element. </p>
<p>Returns a constant reverse iterator to the first dimension of the reversed vector. It corresponds to the last dimension of the original vector. The iterator will be equal to <a class="el" href="a00088.html#a142a7f6785eba59d5f3efb1f97cb22ed" title="Reverse iterator to first element - 1.">rend()</a> for a zero-dimension vector.</p>
<dl class="section return"><dt>Returns</dt><dd>A constant reverse iterator to the first dimension. </dd></dl>

</div>
</div>
<a id="a2702f121eaef8d97f30b482fed56c509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2702f121eaef8d97f30b482fed56c509">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#adbdec14f43e66c6b2204317f041d7185">reverse_iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse iterator to last element. </p>
<p>Returns a reverse iterator to the first dimension of the reversed vector. It corresponds to the last dimension of the original vector. The iterator will be equal to <a class="el" href="a00088.html#a142a7f6785eba59d5f3efb1f97cb22ed" title="Reverse iterator to first element - 1.">rend()</a> for a zero-dimension vector.</p>
<p>This can be used for looping through the dimensions of a vector.</p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the first dimension. </dd></dl>

</div>
</div>
<a id="a604df9d4e4e6f410a82e156dd717a535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604df9d4e4e6f410a82e156dd717a535">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#a0346035577f39d20980aec3b2acc3839">const_reverse_iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const reverse iterator to first element - 1. </p>
<p>Returns a constant reverse iterator to the element following the last dimension of the reversed vector. It corresponds to the element preceding the first dimension of the original vector.</p>
<p>This iterator is a placeholder and attempting to access it will result in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>A constant reverse iterator to the element following the last dimension. </dd></dl>

</div>
</div>
<a id="a142a7f6785eba59d5f3efb1f97cb22ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142a7f6785eba59d5f3efb1f97cb22ed">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html#adbdec14f43e66c6b2204317f041d7185">reverse_iterator</a> <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse iterator to first element - 1. </p>
<p>Returns a reverse iterator to the element following the last dimension of the reversed vector. It corresponds to the element preceding the first dimension of the original vector.</p>
<p>This iterator is a placeholder and attempting to access it will result in undefined behavior.</p>
<p>This can be used for looping through the dimensions of a vector.</p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the element following the last dimension. </dd></dl>

</div>
</div>
<a id="a706197199863f1748ce354de928a13de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706197199863f1748ce354de928a13de">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t D, typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="a00088.html">svector::Vector</a>&lt; D, T &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string form of vector. </p>
<p>This string form can be used for printing.</p>
<dl class="section return"><dt>Returns</dt><dd>The string form of the vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/simplevectors/simplevectors/include/simplevectors/core/<a class="el" href="a00026_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
